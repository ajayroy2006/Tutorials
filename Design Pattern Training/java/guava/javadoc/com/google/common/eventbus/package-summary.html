<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0-google-v6) on Mon Aug 25 14:48:29 EDT 2014 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>com.google.common.eventbus (Guava: Google Core Libraries for Java 18.0 API)</title>
<meta name="date" content="2014-08-25">
<link rel="stylesheet" type="text/css" href="../../../../javadoc-stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="com.google.common.eventbus (Guava: Google Core Libraries for Java 18.0 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/common/escape/package-summary.html">Prev Package</a></li>
<li><a href="../../../../com/google/common/hash/package-summary.html">Next Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/common/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;com.google.common.eventbus</h1>
<div class="docSummary">
<div class="block">The EventBus allows publish-subscribe-style communication between components
 without requiring the components to explicitly register with one another
 (and thus be aware of each other).</div>
</div>
<p>See:&nbsp;<a href="#package_description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="packageSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/SubscriberExceptionHandler.html" title="interface in com.google.common.eventbus">SubscriberExceptionHandler</a></td>
<td class="colLast">
<div class="block">Handler for exceptions thrown by event subscribers.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="packageSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/AsyncEventBus.html" title="class in com.google.common.eventbus">AsyncEventBus</a></td>
<td class="colLast">
<div class="block">An <a href="../../../../com/google/common/eventbus/EventBus.html" title="class in com.google.common.eventbus"><code>EventBus</code></a> that takes the Executor of your choice and uses it to
 dispatch events, allowing dispatch to occur asynchronously.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/DeadEvent.html" title="class in com.google.common.eventbus">DeadEvent</a></td>
<td class="colLast">
<div class="block">Wraps an event that was posted, but which had no subscribers and thus could
 not be delivered.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/EventBus.html" title="class in com.google.common.eventbus">EventBus</a></td>
<td class="colLast">
<div class="block">Dispatches events to listeners, and provides ways for listeners to register
 themselves.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/SubscriberExceptionContext.html" title="class in com.google.common.eventbus">SubscriberExceptionContext</a></td>
<td class="colLast">
<div class="block">Context for an exception thrown by a subscriber.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="packageSummary" border="0" cellpadding="3" cellspacing="0" summary="Annotation Types Summary table, listing annotation types, and an explanation">
<caption><span>Annotation Types Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Annotation Type</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/AllowConcurrentEvents.html" title="annotation in com.google.common.eventbus">AllowConcurrentEvents</a></td>
<td class="colLast">
<div class="block">Marks an event subscriber method as being thread-safe.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus">Subscribe</a></td>
<td class="colLast">
<div class="block">Marks a method as an event subscriber.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package_description">
<!--   -->
</a>
<h2 title="Package com.google.common.eventbus Description">Package com.google.common.eventbus Description</h2>
<div class="block">The EventBus allows publish-subscribe-style communication between components
 without requiring the components to explicitly register with one another
 (and thus be aware of each other).  It is designed exclusively to replace
 traditional Java in-process event distribution using explicit registration.
 It is <em>not</em> a general-purpose publish-subscribe system, nor is it
 intended for interprocess communication.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/EventBusExplained">
 <code>EventBus</code></a>.

 <h2>One-Minute Guide</h2>

 <p>Converting an existing EventListener-based system to use the EventBus is
 easy.

 <h3>For Listeners</h3>
 <p>To listen for a specific flavor of event (say, a CustomerChangeEvent)...
 <ul>
 <li><strong>...in traditional Java events:</strong> implement an interface
     defined with the event &mdash; such as CustomerChangeEventListener.</li>
 <li><strong>...with EventBus:</strong> create a method that accepts
     CustomerChangeEvent as its sole argument, and mark it with the
     <a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a> annotation.</li>
 </ul>

 <p>To register your listener methods with the event producers...
 <ul>
 <li><strong>...in traditional Java events:</strong> pass your object to each
     producer's <code>registerCustomerChangeEventListener</code> method.  These
     methods are rarely defined in common interfaces, so in addition to
     knowing every possible producer, you must also know its type.</li>
 <li><strong>...with EventBus:</strong> pass your object to the
     <a href="../../../../com/google/common/eventbus/EventBus.html#register(java.lang.Object)"><code>EventBus.register(Object)</code></a> method on an
     EventBus.  You'll need to
     make sure that your object shares an EventBus instance with the event
     producers.</li>
 </ul>

 <p>To listen for a common event supertype (such as EventObject or Object)...
 <ul>
 <li><strong>...in traditional Java events:</strong> not easy.</li>
 <li><strong>...with EventBus:</strong> events are automatically dispatched to
     listeners of any supertype, allowing listeners for interface types
     or "wildcard listeners" for Object.</li>
 </ul>

 <p>To listen for and detect events that were dispatched without listeners...
 <ul>
 <li><strong>...in traditional Java events:</strong> add code to each
     event-dispatching method (perhaps using AOP).</li>
 <li><strong>...with EventBus:</strong> subscribe to <a href="../../../../com/google/common/eventbus/DeadEvent.html" title="class in com.google.common.eventbus"><code>DeadEvent</code></a>.  The
     EventBus will notify you of any events that were posted but not
     delivered.  (Handy for debugging.)</li>
 </ul>

 <h3>For Producers</h3>
 <p>To keep track of listeners to your events...
 <ul>
 <li><strong>...in traditional Java events:</strong> write code to manage
     a list of listeners to your object, including synchronization, or use a
     utility class like EventListenerList.</li>
 <li><strong>...with EventBus:</strong> EventBus does this for you.</li>
 </ul>

 <p>To dispatch an event to listeners...
 <ul>
 <li><strong>...in traditional Java events:</strong> write a method to
     dispatch events to each event listener, including error isolation and
     (if desired) asynchronicity.</li>
 <li><strong>...with EventBus:</strong> pass the event object to an EventBus's
     <a href="../../../../com/google/common/eventbus/EventBus.html#post(java.lang.Object)"><code>EventBus.post(Object)</code></a> method.</li>
 </ul>

 <h2>Glossary</h2>

 <p>The EventBus system and code use the following terms to discuss event
 distribution:
 <dl>
 <dt>Event</dt><dd>Any object that may be <em>posted</em> to a bus.</dd>
 <dt>Subscribing</dt><dd>The act of registering a <em>listener</em> with an
     EventBus, so that its <em>subscriber methods</em> will receive events.</dd>
 <dt>Listener</dt><dd>An object that wishes to receive events, by exposing
     <em>subscriber methods</em>.</dt>
 <dt>Subscriber method</dt><dd>A public method that the EventBus should use to
     deliver <em>posted</em> events.  Subscriber methods are marked by the
     <a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a> annotation.</dd>
 <dt>Posting an event</dt><dd>Making the event available to any
     <em>listeners</em> through the EventBus.</dt>
 </dl>

 <h2>FAQ</h2>
 <h3>Why must I create my own Event Bus, rather than using a singleton?</h3>

 <p>The Event Bus doesn't specify how you use it; there's nothing stopping your
 application from having separate EventBus instances for each component, or
 using separate instances to separate events by context or topic.  This also
 makes it trivial to set up and tear down EventBus objects in your tests.

 <p>Of course, if you'd like to have a process-wide EventBus singleton,
 there's nothing stopping you from doing it that way.  Simply have your
 container (such as Guice) create the EventBus as a singleton at global scope
 (or stash it in a static field, if you're into that sort of thing).

 <p>In short, the EventBus is not a singleton because we'd rather not make
 that decision for you.  Use it how you like.

 <h3>Why use an annotation to mark subscriber methods, rather than requiring the
 listener to implement an interface?</h3>
 <p>We feel that the Event Bus's <code>@Subscribe</code> annotation conveys your
 intentions just as explicitly as implementing an interface (or perhaps more
 so), while leaving you free to place event subscriber methods wherever you wish
 and give them intention-revealing names.

 <p>Traditional Java Events use a listener interface which typically sports
 only a handful of methods -- typically one.  This has a number of
 disadvantages:
 <ul>
   <li>Any one class can only implement a single response to a given event.
   <li>Listener interface methods may conflict.
   <li>The method must be named after the event (e.g. <code>handleChangeEvent</code>), rather than its purpose (e.g. <code>recordChangeInJournal</code>).
   <li>Each event usually has its own interface, without a common parent
       interface for a family of events (e.g. all UI events).
 </ul>

 <p>The difficulties in implementing this cleanly has given rise to a pattern,
 particularly common in Swing apps, of using tiny anonymous classes to
 implement event listener interfaces.

 <p>Compare these two cases: <pre>
   class ChangeRecorder {
     void setCustomer(Customer cust) {
       cust.addChangeListener(new ChangeListener() {
         void customerChanged(ChangeEvent e) {
           recordChange(e.getChange());
         }
       };
     }
   }

   // Class is typically registered by the container.
   class EventBusChangeRecorder {
     &#064;Subscribe void recordCustomerChange(ChangeEvent e) {
       recordChange(e.getChange());
     }
   }</pre>

 <p>The intent is actually clearer in the second case: there's less noise code,
 and the event subscriber has a clear and meaningful name.

 <h3>What about a generic <code>Subscriber&lt;T&gt;</code> interface?</h3>
 <p>Some have proposed a generic <code>Subscriber&lt;T&gt;</code> interface for EventBus
 listeners.  This runs into issues with Java's use of type erasure, not to
 mention problems in usability.

 <p>Let's say the interface looked something like the following: <pre>   <code>interface Subscriber&lt;T&gt; {
     void handleEvent(T event);
   }</code></pre>

 <p>Due to erasure, no single class can implement a generic interface more than
 once with different type parameters.  This is a giant step backwards from
 traditional Java Events, where even if <code>actionPerformed</code> and <code>keyPressed</code> aren't very meaningful names, at least you can implement both
 methods!

 <h3>Doesn't EventBus destroy static typing and eliminate automated
 refactoring support?</h3>
 <p>Some have freaked out about EventBus's <code>register(Object)</code> and <code>post(Object)</code> methods' use of the <code>Object</code> type.

 <p><code>Object</code> is used here for a good reason: the Event Bus library
 places no restrictions on the types of either your event listeners (as in
 <code>register(Object)</code>) or the events themselves (in <code>post(Object)</code>).

 <p>Event subscriber methods, on the other hand, must explicitly declare their
 argument type -- the type of event desired (or one of its supertypes).  Thus,
 searching for references to an event class will instantly find all subscriber
 methods for that event, and renaming the type will affect all subscriber methods
 within view of your IDE (and any code that creates the event).

 <p>It's true that you can rename your <code>@Subscribed</code> event subscriber
 methods at will; Event Bus will not stop this or do anything to propagate the
 rename because, to Event Bus, the names of your subscriber methods are
 irrelevant.  Test code that calls the methods directly, of course, will be
 affected by your renaming -- but that's what your refactoring tools are for.

 <h3>What happens if I <code>register</code> a listener without any subscriber
 methods?</h3>
 <p>Nothing at all.

 <p>The Event Bus was designed to integrate with containers and module
 systems, with Guice as the prototypical example.  In these cases, it's
 convenient to have the container/factory/environment pass <i>every</i>
 created object to an EventBus's <code>register(Object)</code> method.

 <p>This way, any object created by the container/factory/environment can
 hook into the system's event model simply by exposing subscriber methods.

 <h3>What Event Bus problems can be detected at compile time?</h3>
 <p>Any problem that can be unambiguously detected by Java's type system.  For
 example, defining a subscriber method for a nonexistent event type.

 <h3>What Event Bus problems can be detected immediately at registration?</h3>
 <p>Immediately upon invoking <code>register(Object)</code> , the listener being
 registered is checked for the <i>well-formedness</i> of its subscriber methods.
 Specifically, any methods marked with <code>@Subscribe</code> must take only a
 single argument.

 <p>Any violations of this rule will cause an <code>IllegalArgumentException</code>
 to be thrown.

 <p>(This check could be moved to compile-time using APT, a solution we're
 researching.)

 <h3>What Event Bus problems may only be detected later, at runtime?</h3>
 <p>If a component posts events with no registered listeners, it <i>may</i>
 indicate an error (typically an indication that you missed a
 <code>@Subscribe</code> annotation, or that the listening component is not loaded).

 <p>(Note that this is <i>not necessarily</i> indicative of a problem.  There
 are many cases where an application will deliberately ignore a posted event,
 particularly if the event is coming from code you don't control.)

 <p>To handle such events, register a subscriber method for the <code>DeadEvent</code>
 class.  Whenever EventBus receives an event with no registered subscribers, it
 will turn it into a <code>DeadEvent</code> and pass it your way -- allowing you to
 log it or otherwise recover.

 <h3>How do I test event listeners and their subscriber methods?</h3>
 <p>Because subscriber methods on your listener classes are normal methods, you can
 simply call them from your test code to simulate the EventBus.</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/common/escape/package-summary.html">Prev Package</a></li>
<li><a href="../../../../com/google/common/hash/package-summary.html">Next Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/common/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2010-2014. All Rights Reserved.</small></p>
</body>
</html>
